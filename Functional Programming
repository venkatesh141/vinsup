Functional programming in Java is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids changing state and mutable data. Java introduced functional programming features starting from Java 8 with lambda expressions and the Stream API.
🔹 Key Features of Functional Programming in Java

    First-Class Functions
    Functions can be assigned to variables, passed as arguments, and returned from other functions.

    Higher-Order Functions
    A function can take another function as a parameter or return a function.

    Immutability
    Functional programming promotes using immutable data to avoid side effects.

    Pure Functions
    Functions always return the same output for the same input and have no side effects.

    Lazy Evaluation
    Computation is deferred until the value is needed (e.g., Stream operations).

🔹 Functional Programming Concepts in Java
1️⃣ Lambda Expressions

Lambda expressions are anonymous functions that make code more concise.

// Without Lambda
interface MyFunction {
    int add(int a, int b);
}

public class Main {
    public static void main(String[] args) {
        MyFunction sum = new MyFunction() {
            @Override
            public int add(int a, int b) {
                return a + b;
            }
        };
        System.out.println(sum.add(5, 3));  // Output: 8
    }
}

// With Lambda
interface MyFunction {
    int add(int a, int b);
}

public class Main {
    public static void main(String[] args) {
        MyFunction sum = (a, b) -> a + b;
        System.out.println(sum.add(5, 3));  // Output: 8
    }
}

2️⃣ Functional Interfaces

A functional interface has exactly one abstract method and can be implemented using a lambda expression.
Common Functional Interfaces in Java:

    Function<T, R> – Takes one input, returns one output
    Consumer<T> – Takes one input, returns nothing (used for side effects)
    Supplier<T> – Takes no input, returns one output
    Predicate<T> – Takes one input, returns boolean

import java.util.function.Function;

public class Main {
    public static void main(String[] args) {
        Function<Integer, Integer> square = n -> n * n;
        System.out.println(square.apply(4));  // Output: 16
    }
}

3️⃣ Streams API (Lazy Evaluation)

Java Streams provide a functional way to process collections.

import java.util.Arrays;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        // Using Streams to find the sum of even numbers
        int sum = numbers.stream()
                         .filter(n -> n % 2 == 0)  // Only even numbers
                         .mapToInt(n -> n)         // Convert to int
                         .sum();

        System.out.println(sum);  // Output: 6 (2 + 4)
    }
}

4️⃣ Method References

A method reference (::) is a shorthand for a lambda expression.

import java.util.Arrays;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

        // Using Method Reference
        names.forEach(System.out::println);
    }
}

🔹 Advantages of Functional Programming in Java

✔ Concise & Readable – Less boilerplate code
✔ Parallel Execution – Streams allow easy parallel processing
✔ Improved Maintainability – No side effects, making debugging easier
✔ More Expressive – Functional interfaces and lambdas make code easier to understand
🔹 When to Use Functional Programming in Java?

✅ When working with collections (use Streams)
✅ When writing event-driven code (functional interfaces)
✅ When you need concurrent execution (parallel streams)
✅ When performing mathematical computations (pure functions)
🔹 Summary

    Java supports functional programming via lambda expressions, Streams, and functional interfaces.
    It helps in writing clean, concise, and parallelizable code.
    Functional programming promotes immutability, pure functions, and higher-order functions.


